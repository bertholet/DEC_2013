#pragma once
#include <vector>
#include <iostream>
#include <fstream>
#include <string>
#include "matrixCreator.h"
#include "tuple3.h"
#include "DECCORE_EXPORT.h"

//////////////////////////////////////////////////////////////////////////
//Indices are 0-based.
//
//////////////////////////////////////////////////////////////////////////

class DECCORE_EXPORT cpuCSRMatrix
{
private:
	//////////////////////////////////////////////////////////////////////////
	//indices of the values in the sparse matrix
	//ia: the offsets of the values of a row in a and ja
	//ja: the column indices
	//////////////////////////////////////////////////////////////////////////
	std::vector<int> ia, ja;
	//values of the elements of the sparse matrix
	std::vector<float> a;

	int n, m;


	//////////////////////////////////////////////////////////////////////////
	// Matrix multiplication with transposed matrix. Rather
	// mediocrely efficient. Use for onetime construction of reused matrix
	// where efficiency is not as important.
	//////////////////////////////////////////////////////////////////////////
	cpuCSRMatrix operator % (cpuCSRMatrix & other);

public:
	cpuCSRMatrix(void);
	//////////////////////////////////////////////////////////////////////////
	// vals are copied. a is assumed to have the same size as ja. Do not forget
	// that the last element of i_a has to be #values and thus has #rows + 1
	// values.
	//////////////////////////////////////////////////////////////////////////
	cpuCSRMatrix(int * ia_, int * ja_,float * a_,
		 int sz_ia, int sz_ja);
	~cpuCSRMatrix(void);


	//////////////////////////////////////////////////////////////////////////
	// creator describes the matrix in 0 based notation
	//////////////////////////////////////////////////////////////////////////
	void initMatrix(matrixCreator & creator, int dim);


	//////////////////////////////////////////////////////////////////////////
	// clear all data stored
	//////////////////////////////////////////////////////////////////////////
	void clear();

	//////////////////////////////////////////////////////////////////////////
	// return first dim of this matrix.
	//////////////////////////////////////////////////////////////////////////
	int dim();

	//////////////////////////////////////////////////////////////////////////
	// getter
	//////////////////////////////////////////////////////////////////////////
	// get the row offsets
	std::vector<int> & getia(void){
		return ia;
	}
	//get the column indices
	std::vector<int> & getja(void){
		return ja;
	}
	//get the values
	std::vector<float> & geta(void){
		return a;
	}

	//////////////////////////////////////////////////////////////////////////
	// nr Rows
	//////////////////////////////////////////////////////////////////////////
	int getn(){
		return n;
	}
	//////////////////////////////////////////////////////////////////////////
	// nr Columns
	//////////////////////////////////////////////////////////////////////////
	int getm(){
		return m;
	}

	//////////////////////////////////////////////////////////////////////////
	// psuhback with adaptation of dimension variables.
	//////////////////////////////////////////////////////////////////////////
	void iapush_back(int i){
		ia.push_back(i);
		n = ia.size()-1;
	}
	void japush_back(int j){
		ja.push_back(j);
		if(j+1 > m){
			m = j+1;
		}
	}

	void apush_back(float val){
		a.push_back(val);
	}
	

	//////////////////////////////////////////////////////////////////////////
	// store Matrix in matlab executable format in a file.
	// Handy for debugging and analysis.
	// stores the matrix with 1-based indices (for matlab).
	//////////////////////////////////////////////////////////////////////////
	void saveMatrix(std::string file);
	/*void saveVector(std::vector<double> & vctor, std::string  name, 
		std::string  file );
	void saveVector(std::vector<int> & vctor, std::string  name, 
		std::string  file );*/

	//////////////////////////////////////////////////////////////////////////
	// Stores the indices i in target, such that a[i] is a value on the diagonal
	// Usefull e.g if you want to add epsilon to the diagonal.
	//////////////////////////////////////////////////////////////////////////
	void getDiagonalIndices( std::vector<int> & target_ind );

	//////////////////////////////////////////////////////////////////////////
	// IF and only IF mat has an entry at i,j, val is added.
	// i, j in ZERO based notation
	// ELSE an assertion will fail and an error be thrown
	//////////////////////////////////////////////////////////////////////////
	void add( int i, int j, float val );
	void set(int i , int j, float val);
	float get(int i , int j);


	//////////////////////////////////////////////////////////////////////////
	// set line line to 0.... 1 ... 0 where line is the line in 0 based notation
	//////////////////////////////////////////////////////////////////////////
	void setLineToID( int line );

	void setLineToZero( int line );

	//////////////////////////////////////////////////////////////////////////
	// This method will replace all values in this Matrix by 1/val
	// For diagonalmatrices (only!) this gives the inverse.
	// Convenience Method
	//////////////////////////////////////////////////////////////////////////
	void elementWiseInv();


	//////////////////////////////////////////////////////////////////////////
	// Matrix multiplication. Note that even it is handy to use, a temporary
	// sparse matrix is created and returned BY VALUE, so this method is not
	//efficient
	// Note also: this works only for Matrices that are fully stored, i.e. symmetricity is not used 
	// by storing only the upper half of the matrix
	//////////////////////////////////////////////////////////////////////////
	cpuCSRMatrix operator*(cpuCSRMatrix & other);

	//////////////////////////////////////////////////////////////////////////
	// multiply matrix with scalar value
	//////////////////////////////////////////////////////////////////////////
	void operator *=(float  other);

	// multiply matrix with scalar value
	//////////////////////////////////////////////////////////////////////////
	cpuCSRMatrix operator *(float  other);



	//////////////////////////////////////////////////////////////////////////
	// get a transposed copy of the matrix mat
	// Inefficient.
	//////////////////////////////////////////////////////////////////////////
	static cpuCSRMatrix  transpose(cpuCSRMatrix & mat);



	//////////////////////////////////////////////////////////////////////////
	// addition
	//////////////////////////////////////////////////////////////////////////
	cpuCSRMatrix operator + (cpuCSRMatrix & other);

	//////////////////////////////////////////////////////////////////////////
	// substraction
	//////////////////////////////////////////////////////////////////////////
	cpuCSRMatrix operator - (cpuCSRMatrix & other);


	//////////////////////////////////////////////////////////////////////////
	// multiplication with vector
	//////////////////////////////////////////////////////////////////////////
	void mult(std::vector<double> & x, std::vector<double> & target, bool adaptTargetSize = false);

	//////////////////////////////////////////////////////////////////////////
	// component wise multiplication with the vectors x.x, x.y, x.z, stored
	// into target.x, target.y, target.z
	//////////////////////////////////////////////////////////////////////////
	void mult(std::vector<tuple3f> & x, std::vector<tuple3f> & target, bool adaptTargetSize = false);

	//////////////////////////////////////////////////////////////////////////
	// Adds a row at the end of the matrix. js are the column indices of the
	// values vals. The indices have to be 0 based.
	//////////////////////////////////////////////////////////////////////////
	void addLine(std::vector<int> & js, std::vector<float> & vals);

	void forceNrColumns( int nrColumns );
	void getLine( int line, std::vector<int> & target_ind, std::vector<float> & target_vals );
	
	//appends the matrix mat at the right bottom corner of this matrix
	void diagAppend( cpuCSRMatrix & mat );
	void append(cpuCSRMatrix & mat);
	void scaleLine( int line, float scale );
	//////////////////////////////////////////////////////////////////////////
	//Normalizes the matrix rows such that the absolute value of the diagonal
	//elements is one.
	//////////////////////////////////////////////////////////////////////////
	void normalizeLines();
	//adds val to all elemetns on the diagonal
	void addOnDiagonal( float val );
};
